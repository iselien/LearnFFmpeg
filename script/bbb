BEGIN { ARGC=__ARGC=split(__ARGV, ARGV, "       ")+1; ARGV[0]=__ARGV0; RS=FS="
" JSON=""; TYPE=""; __KEYS=""; __jawk__init() } /^---/ { FILENAME=substr($0, 4); __FNR=0; next } { ARGC=__ARGC; __parse_value($0); $0=_[JSON]; NR=++__NR; FNR=++__FNR } function __jawk__init(i) { __CHAR[0] = ""; __CHAR[1] = ""; __CHAR[2] = "" __CHAR[3] = ""; __CHAR[4] = ""; __CHAR[5] = "" __CHAR[6] = ""; __CHAR[7] = ""; __CHAR[8] = " __CHAR[9] = "        "; __CHAR[10] = "
"; __CHAR[11] = "
                 " __CHAR[12] = "
"; __CHAR[14] = "" __CHAR[15] = ""; __CHAR[16] = ""; __CHAR[17] = "" __CHAR[18] = ""; __CHAR[19] = ""; __CHAR[20] = "" __CHAR[21] = ""; __CHAR[22] = ""; __CHAR[23] = "" __CHAR[24] = ""; __CHAR[25] = ""; __CHAR[26] = "" __CHAR[27] = " __CHAR[28] = ""; __CHAR[29] = "" __CHAR[30] = ""; __CHAR[31] = ""; __CHAR[32] = " " __CHAR[33] = "!"; __CHAR[34] = """; __CHAR[35] = "#" __CHAR[36] = "$"; __CHAR[37] = "%"; __CHAR[38] = "&" __CHAR[39] = "'"; __CHAR[40] = "("; __CHAR[41] = ")" __CHAR[42] = "*"; __CHAR[43] = "+"; __CHAR[44] = "," __CHAR[45] = "-"; __CHAR[46] = "."; __CHAR[47] = "/" __CHAR[48] = "0"; __CHAR[49] = "1"; __CHAR[50] = "2" __CHAR[51] = "3"; __CHAR[52] = "4"; __CHAR[53] = "5" __CHAR[54] = "6"; __CHAR[55] = "7"; __CHAR[56] = "8" __CHAR[57] = "9"; __CHAR[58] = ":"; __CHAR[59] = ";" __CHAR[60] = "<"; __CHAR[61] = "="; __CHAR[62] = ">" __CHAR[63] = "?"; __CHAR[64] = "@"; __CHAR[65] = "A" __CHAR[66] = "B"; __CHAR[67] = "C"; __CHAR[68] = "D" __CHAR[69] = "E"; __CHAR[70] = "F"; __CHAR[71] = "G" __CHAR[72] = "H"; __CHAR[73] = "I"; __CHAR[74] = "J" __CHAR[75] = "K"; __CHAR[76] = "L"; __CHAR[77] = "M" __CHAR[78] = "N"; __CHAR[79] = "O"; __CHAR[80] = "P" __CHAR[81] = "Q"; __CHAR[82] = "R"; __CHAR[83] = "S" __CHAR[84] = "T"; __CHAR[85] = "U"; __CHAR[86] = "V" __CHAR[87] = "W"; __CHAR[88] = "X"; __CHAR[89] = "Y" __CHAR[90] = "Z"; __CHAR[91] = "["; __CHAR[92] = "\" __CHAR[93] = "]"; __CHAR[94] = "^"; __CHAR[95] = "_" __CHAR[96] = "`"; __CHAR[97] = "a"; __CHAR[98] = "b" __CHAR[99] = "c"; __CHAR[100] = "d"; __CHAR[101] = "e" __CHAR[102] = "f"; __CHAR[103] = "g"; __CHAR[104] = "h" __CHAR[105] = "i"; __CHAR[106] = "j"; __CHAR[107] = "k" __CHAR[108] = "l"; __CHAR[109] = "m"; __CHAR[110] = "n" __CHAR[111] = "o"; __CHAR[112] = "p"; __CHAR[113] = "q" __CHAR[114] = "r"; __CHAR[115] = "s"; __CHAR[116] = "t" __CHAR[117] = "u"; __CHAR[118] = "v"; __CHAR[119] = "w" __CHAR[120] = "x"; __CHAR[121] = "y"; __CHAR[122] = "z" __CHAR[123] = "{"; __CHAR[124] = "|"; __CHAR[125] = "}" __CHAR[126] = "~"; __CHAR[127] = ""; __CHAR[128] = "�" __CHAR[129] = "�"; __CHAR[130] = "�"; __CHAR[131] = "�" __CHAR[132] = "�"; __CHAR[133] = "�"; __CHAR[134] = "�" __CHAR[135] = "�"; __CHAR[136] = "�"; __CHAR[137] = "�" __CHAR[138] = "�"; __CHAR[139] = "�"; __CHAR[140] = "�" __CHAR[141] = "�"; __CHAR[142] = "�"; __CHAR[143] = "�" __CHAR[144] = "�"; __CHAR[145] = "�"; __CHAR[146] = "�" __CHAR[147] = "�"; __CHAR[148] = "�"; __CHAR[149] = "�" __CHAR[150] = "�"; __CHAR[151] = "�"; __CHAR[152] = "�" __CHAR[153] = "�"; __CHAR[154] = "�"; __CHAR[155] = "�" __CHAR[156] = "�"; __CHAR[157] = "�"; __CHAR[158] = "�" __CHAR[159] = "�"; __CHAR[160] = "�"; __CHAR[161] = "�" __CHAR[162] = "�"; __CHAR[163] = "�"; __CHAR[164] = "�" __CHAR[165] = "�"; __CHAR[166] = "�"; __CHAR[167] = "�" __CHAR[168] = "�"; __CHAR[169] = "�"; __CHAR[170] = "�" __CHAR[171] = "�"; __CHAR[172] = "�"; __CHAR[173] = "�" __CHAR[174] = "�"; __CHAR[175] = "�"; __CHAR[176] = "�" __CHAR[177] = "�"; __CHAR[178] = "�"; __CHAR[179] = "�" __CHAR[180] = "�"; __CHAR[181] = "�"; __CHAR[182] = "�" __CHAR[183] = "�"; __CHAR[184] = "�"; __CHAR[185] = "�" __CHAR[186] = "�"; __CHAR[187] = "�"; __CHAR[188] = "�" __CHAR[189] = "�"; __CHAR[190] = "�"; __CHAR[191] = "�" __CHAR[192] = "�"; __CHAR[193] = "�"; __CHAR[194] = "�" __CHAR[195] = "�"; __CHAR[196] = "�"; __CHAR[197] = "�" __CHAR[198] = "�"; __CHAR[199] = "�"; __CHAR[200] = "�" __CHAR[201] = "�"; __CHAR[202] = "�"; __CHAR[203] = "�" __CHAR[204] = "�"; __CHAR[205] = "�"; __CHAR[206] = "�" __CHAR[207] = "�"; __CHAR[208] = "�"; __CHAR[209] = "�" __CHAR[210] = "�"; __CHAR[211] = "�"; __CHAR[212] = "�" __CHAR[213] = "�"; __CHAR[214] = "�"; __CHAR[215] = "�" __CHAR[216] = "�"; __CHAR[217] = "�"; __CHAR[218] = "�" __CHAR[219] = "�"; __CHAR[220] = "�"; __CHAR[221] = "�" __CHAR[222] = "�"; __CHAR[223] = "�"; __CHAR[224] = "�" __CHAR[225] = "�"; __CHAR[226] = "�"; __CHAR[227] = "�" __CHAR[228] = "�"; __CHAR[229] = "�"; __CHAR[230] = "�" __CHAR[231] = "�"; __CHAR[232] = "�"; __CHAR[233] = "�" __CHAR[234] = "�"; __CHAR[235] = "�"; __CHAR[236] = "�" __CHAR[237] = "�"; __CHAR[238] = "�"; __CHAR[239] = "�" __CHAR[240] = "�"; __CHAR[241] = "�"; __CHAR[242] = "�" __CHAR[243] = "�"; __CHAR[244] = "�"; __CHAR[245] = "�" __CHAR[246] = "�"; __CHAR[247] = "�"; __CHAR[248] = "�" __CHAR[249] = "�"; __CHAR[250] = "�"; __CHAR[251] = "�" __CHAR[252] = "�"; __CHAR[253] = "�"; __CHAR[254] = "�" __CHAR[255] = "�" __UNESCAPE["\b"] = "; __UNESCAPE["\f"] = "
                                                                                                                                                                          " __UNESCAPE["\n"] = "
" __UNESCAPE["\t"] = "" "; __UNESCAPE["\\""] = "\"" __UNESCAPE["\\"] = "\"; __UNESCAPE["\/"] = "/" for (i = 0; i < 256; i++) __HEX[sprintf("%02X", i)] = i } function __utf8enc(c) { if (c <= 127) { return __CHAR[c] } else if (c <= 2047) { return __CHAR[192 + int(c/64)] __CHAR[128 + (c%64)] } else if (c <= 65535) { return __CHAR[224 + int(c/4096)] \ __CHAR[128 + (int(c/64) % 64)] \ __CHAR[128 + (c%64)] } else if (c <= 1114111) { return __CHAR[240 + int(c/262144)] \ __CHAR[128 + (int(c/4096) % 64)] \ __CHAR[128 + (int(c/64) % 64)] \ __CHAR[128 + (c%64)] } } function __hextodec(h) { h = toupper(h) return 256 and.sh case.sh cd.sh data.json extra_json.sh first.sh fun.sh if.sh jawk json.sh or.sh serial.sh test_command.sh try_var.sh until.sh while.sh __HEX[substr(h, 1, 2)] + __HEX[substr(h, 3)] } function __unescape(s, i, s2, c, u, h) { i = match(s, /\([bfnrt"\\/]|u[0-9a-fA-F]{4})/) if (!i) return s s2 = "" while (i) { c = substr(s, RSTART, RLENGTH) if (c in __UNESCAPE) u = __UNESCAPE[c] else { h = __hextodec(substr(c, 3)) if (h >= 55296 && h <= 56319) { c = substr(s, RSTART + RLENGTH, 6) RLENGTH += 6 h = 65536 + ((h - 55296) and.sh case.sh cd.sh data.json extra_json.sh first.sh fun.sh if.sh jawk json.sh or.sh serial.sh test_command.sh try_var.sh until.sh while.sh 1024) + \ (__hextodec(substr(c, 3)) - 56320) } u = __utf8enc(h) } s2 = s2 substr(s, 1, RSTART - 1) u s = substr(s, RSTART + RLENGTH) i = match(s, /\([bfnrt"\\/]|u[0-9a-fA-F]{4})/) } s2 = s2 s return s2 } function keys(a, o, n, i) { if (o == "" && o == 0) { if ((__KEYS,"length") in _) { n = _[__KEYS,"length"] while (++i <= n) a[_[__KEYS,i]] = _[__KEYS,i] } else { n = _["length"] while (++i <= _["length"]) a[i] = i } } else { if ((o,__KEYS,"length") in _) { n = _[o,__KEYS,"length"] while (++i <= n) a[_[o,__KEYS,i]] = o SUBSEP _[o,__KEYS,i] } else { n = _[o,"length"] while (++i <= n) a[i] = o SUBSEP i } } return n } function __error(t) { printf "%s: unexpected token %s
", __ARGV0, t >"/dev/stderr" exit 1 } function __get_token(t) { if (getline t == -1) { printf "%s: read error
", __ARGV0 >"/dev/stderr" exit 1 } if (t == "") { printf "%s: unexpected EOF
", __ARGV0 >"/dev/stderr" exit 1 } return t } function __parse_array(path, i, sep, raw_value, value) { i = 0 sep = "" raw_value = "[" while (sep != "]") { value = __get_token() if (value == "]") { if (sep) __error(value) raw_value = raw_value value break } value = __parse_value(value, __getpath(path, ++i)) sep = __get_token() if (sep != "," && sep != "]") __error(sep) raw_value = raw_value value sep } _[__getpath(path, "length")] = i return raw_value } function __parse_value(value, path, raw_value, start, type) { start = substr(value, 1, 1) if (start == "{") { _[path] = path type = "object" raw_value = __parse_object(path) } else if (start == "[") { _[path] = path type = "array" raw_value = __parse_array(path) } else { raw_value = value if (start == "\"" && length(value) > 1) { value = __unescape(substr(value, 2, length(value) - 2)) type = "string" } else if (value == "true") { value = 1 type = "boolean" } else if (value == "false") { value = 0 type = "boolean" } else if (value == "null") { value = "" type = "null" } else if (value ~ /^-?[0-9]/) { type = "number" } else { __error(value) } if (path == "" && path == 0) _[0] = value else _[path] = value } _[__getpath(path, JSON)] = raw_value _[__getpath(path, TYPE)] = type return raw_value } function __getpath(path, key) { return path == "" && path == 0 ? key : path SUBSEP key } function __parse_object(path, sep, i, raw_value, key, colon, value, raw_key) { sep = "" i = 0 raw_value = "{" while (sep != "}") { key = __get_token() if (key == "}") { if (sep) __error(key) raw_value = raw_value key break } if (length(key) < 2) __error(key) raw_key = key key = substr(key, 2, length(key) - 2) colon = __get_token() if (colon != ":") __error(colon) value = __parse_value(__get_token(), __getpath(path, key)) sep = __get_token() if (sep != "," && sep != "}") __error(sep) raw_value = raw_value raw_key colon value sep ++i _[__getpath(path, __KEYS SUBSEP i)] = key } _[__getpath(path, __KEYS SUBSEP "length")] = i return raw_value } {print _["age"]} BEGIN { ARGC=1; RS=FS="
" } { ARGC=1; RS=FS="
" }